<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-30T20:36:35+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">fw0x</title><subtitle>Stay hungry, stay foolish.</subtitle><entry><title type="html">【60天重学左耳】Day15-弹力设计篇之“补偿事务“</title><link href="http://localhost:4000/code/2019/12/30/cxze60-day15.html" rel="alternate" type="text/html" title="【60天重学左耳】Day15-弹力设计篇之“补偿事务“" /><published>2019-12-30T20:00:00+08:00</published><updated>2019-12-30T20:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/30/cxze60-day15</id><content type="html" xml:base="http://localhost:4000/code/2019/12/30/cxze60-day15.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day15：今天学习了《46｜弹力设计篇之“补偿事务”》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CAP理论：在分布式的服务架构中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance），最多只能满足其中两个。&lt;/li&gt;
  &lt;li&gt;ACID：即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。强调一致性（CAP的C）。&lt;/li&gt;
  &lt;li&gt;BASE：基本可用（Basic Availability）、软状态（Soft State）、最终一致性（Eventual Consistency）。强调可用性（CAP的A）。&lt;/li&gt;
  &lt;li&gt;ACID和BASE比较：ACID有更强的一致性，可伸缩性差；BASE的一致性较弱，可伸缩性很好，还可以异步批量处理。大多数分布式事务适合BASE。&lt;/li&gt;
  &lt;li&gt;业务补偿：努力地把一个业务流程执行完成、如果执行不下去，需要启动补偿机制，回滚业务流程。&lt;/li&gt;
  &lt;li&gt;业务补偿的设计重点：服务方支撑幂等性、上游有重试机制；控制整个业务流程的高可用的工作流引擎；设计业务的反向补偿流程；强业务相关很难做成通用的；下层业务方提供短期资源预留机制（下单后15分钟支付时间）。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day12-弹力设计篇之“服务的状态“</title><link href="http://localhost:4000/code/2019/12/27/cxze60-day12.html" rel="alternate" type="text/html" title="【60天重学左耳】Day12-弹力设计篇之“服务的状态“" /><published>2019-12-27T23:00:00+08:00</published><updated>2019-12-27T23:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/27/cxze60-day12</id><content type="html" xml:base="http://localhost:4000/code/2019/12/27/cxze60-day12.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day12：今天学习了《45｜弹力设计篇之“服务的状态”》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;状态：就是为了保留程序的一些数据或是上下文。比如登陆Session、业务逻辑运行上下文Context。&lt;/li&gt;
  &lt;li&gt;函数式编程：immutable不变的，只描述其逻辑和算法，根本不保存数据，也不会修改输入的数据，而是把计算好的结果返回出去。&lt;/li&gt;
  &lt;li&gt;无状态服务Stateless：分布式服务设计的最佳实践和铁律，扩展性和运维方便，可以随意增减节点，随意搬迁，无明显副作用。需要保状态保存到第三方有状态的存储服务，如Redis、MySQL、Zookeeper、Etcd、或分布式文件系统。缺点是增加了网络开销，而在本地缓存有会浪费资源。&lt;/li&gt;
  &lt;li&gt;有状态服务Steteful的好处：数据本地化（Data Locality）；更高的可用性和更强的一致性，即CAP的AC。&lt;/li&gt;
  &lt;li&gt;无状态服务把数据同步到不同节点，有状态服务通过Sticky Session做数据分片。&lt;/li&gt;
  &lt;li&gt;Sticky Session的实现方式：持久化的长连接（一致性哈希、uid求模）；Gossip协议（节点间互相同步元数据）。&lt;/li&gt;
  &lt;li&gt;服务状态的容错设计：Sticky Session的方式在实际运维过程中复杂度太高；最好利用分布式文件系统，在节点挂掉时快速启动新实例。&lt;/li&gt;
  &lt;li&gt;很多系统的高可用设计会采取数据在运行时就复制的方案，比如：ZooKeeper、Kafka、Redis 或是 ElasticSearch 等等。强一致性的系统一般会使用两阶段提交。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day11-弹力设计篇之“异步通讯设计”和“幂等性设计“</title><link href="http://localhost:4000/code/2019/12/26/cxze60-day11.html" rel="alternate" type="text/html" title="【60天重学左耳】Day11-弹力设计篇之“异步通讯设计”和“幂等性设计“" /><published>2019-12-26T23:30:00+08:00</published><updated>2019-12-26T23:30:00+08:00</updated><id>http://localhost:4000/code/2019/12/26/cxze60-day11</id><content type="html" xml:base="http://localhost:4000/code/2019/12/26/cxze60-day11.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day11：今天学习了《43｜弹力设计篇之“异步通讯设计”》和《44｜弹力设计篇之“幂等性设计”》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通讯一般分同步和异步。同步通讯就像打电话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。&lt;/li&gt;
  &lt;li&gt;同步调用的问题：需要被调用方的吞吐不低于调用方的吞吐（整个同步调用链的性能会由最慢的那个服务所决定）；调用方一直在等待被调用方完成（并发较高场景极度消耗资源）；只能是一对一的，很难做到一对多；被调用方有问题，其调用方跟着出问题（多米诺骨牌效应）。&lt;/li&gt;
  &lt;li&gt;异步通讯的好处：增加系统的吞吐量，让服务间的解耦更为彻底，让系统的调用方和被调用方按照自己的速率来处理，系统更有弹力。&lt;/li&gt;
  &lt;li&gt;异步通讯的方式：请求响应（直接请求接收方，异步回调）；直接订阅（接收方向发送方订阅事件，从消息队列获取请求，无状态只依赖事件）；中间人Broker订阅（接收方向Broker订阅消息，发送方向Broker发送消息，互相看不到对方）。&lt;/li&gt;
  &lt;li&gt;事件驱动设计：订阅式和Broker都是事件驱动架构（EDA – Event Driven Architecture），Broker更优。Broker需要的特性：高可用、高性能、可以水平扩展、数据持久化。&lt;/li&gt;
  &lt;li&gt;事件驱动方式的好处：服务间无依赖，服务可重用或被替换；服务的开发、测试、运维高度隔离；服务间不会相互阻塞block；更容易增加Adapter（日志、认证、版本、限流、降级、熔断等）；服务间的吞吐更大，可以按照自己速度来处理）。&lt;/li&gt;
  &lt;li&gt;事件驱动方式的缺点：架构变复杂，需要可视化工具呈现整体业务流程；事件可能乱序，需要管理好状态机；事务处理变复杂，要么两阶段提交做强一致性，要么退缩到最终一致性。&lt;/li&gt;
  &lt;li&gt;异步通讯的注意事项：Broker高可用、服务消息跟踪机制、业务状态总控如银行的对账程序；幂等处理。&lt;/li&gt;
  &lt;li&gt;所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x) = f(f(x))。&lt;/li&gt;
  &lt;li&gt;服务调用的结果：成功（Success），失败（Failed），超时（Timeout）。超时原因包括：请求没有到，请求到了返回结果没有正常返回。超时是完全不知道是什么状态，所以需要解决，手段包括：查询调用结果；被调用服务实现幂等性。&lt;/li&gt;
  &lt;li&gt;分布式系统实现幂等性，需要实现全局ID（如Twitter的 Snowflake）&lt;/li&gt;
  &lt;li&gt;幂等性接口的一般处理流程：收到交易请求时，到存储中去查询。如果查找到了，就把上次做的结果返回。如果没有查到，那么我们就记录下来。&lt;/li&gt;
  &lt;li&gt;HTTP的幂等性：GET/HEAD/OPTIONS/DELETE/PUT满足幂等，POST不满足幂等。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day10-弹力设计篇之“隔离设计”</title><link href="http://localhost:4000/code/2019/12/25/cxze60-day10.html" rel="alternate" type="text/html" title="【60天重学左耳】Day10-弹力设计篇之“隔离设计”" /><published>2019-12-25T21:00:00+08:00</published><updated>2019-12-25T21:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/25/cxze60-day10</id><content type="html" xml:base="http://localhost:4000/code/2019/12/25/cxze60-day10.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day10：今天学习了《42｜弹力设计篇之“隔离设计”》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;隔离设计Bulkheads，源于造船上的隔板技术，也就是船体水密舱。&lt;/li&gt;
  &lt;li&gt;系统分离的方式：按服务种类、按用户请求。&lt;/li&gt;
  &lt;li&gt;按服务种类分离：使用不同的域名、服务器和数据库，做到从接入层到应用层再到数据层三层完全隔离。&lt;/li&gt;
  &lt;li&gt;完全隔离的问题：跨业务板块调用性能会降低（响应时间）；数据合并复杂度变高；跨板块的服务交互变复杂；分布式事务问题。&lt;/li&gt;
  &lt;li&gt;按用户请求分离：同一个服务对于不同的用户进行冗余和隔离。&lt;/li&gt;
  &lt;li&gt;按服务种类和按用户请求分离可以融合，即多租户模式。三种做法：完全独立；独立的数据分区，共享的服务；共享的服务，共享的数据分区。&lt;/li&gt;
  &lt;li&gt;通过虚拟化技术（Hypervior如KVM，或是Linux Container如Docker）来实现物理资源的共享和成本的节约，并且可以做到几乎完全隔离。&lt;/li&gt;
  &lt;li&gt;隔离设计的重点：定义好隔离业务的大小和粒度；定义好要什么和不要什么（考虑系统的复杂度、成本、性能、资源使用）；跟高可用、重试、异步、消息中间件、流控、熔断等设计模式配套使用；自动化运维工具；能看到所有服务的监控系统。&lt;/li&gt;
  &lt;li&gt;找到一个合适的均衡方案，我们不可能做出一个什么都能满足的系统。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day09-弹力设计篇之“认识故障和弹力设计”</title><link href="http://localhost:4000/code/2019/12/24/cxze60-day09.html" rel="alternate" type="text/html" title="【60天重学左耳】Day09-弹力设计篇之“认识故障和弹力设计”" /><published>2019-12-24T23:30:00+08:00</published><updated>2019-12-24T23:30:00+08:00</updated><id>http://localhost:4000/code/2019/12/24/cxze60-day09</id><content type="html" xml:base="http://localhost:4000/code/2019/12/24/cxze60-day09.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day9：今天学习了《41｜弹力设计篇之“认识故障和弹力设计”》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;分布式系统关键的设计模式：容错（弹力Resiliency）、性能、管理。&lt;/li&gt;
  &lt;li&gt;弹力：系统在不健康、不顺，甚至出错的情况下有能力hold得住，挺得住，能在逆境中力挽狂澜。&lt;/li&gt;
  &lt;li&gt;系统可用性测量：Availability = MTTF / MTTR + MTTF​。MTTF 是 Mean Time To Failure，平均故障前的时间。MTTR 是 Mean Time To Recovery，平均修复时间。为了提高可用性，我们要么提高系统的无故障时间，要么减少系统的故障恢复时间。&lt;/li&gt;
  &lt;li&gt;故障原因：无计划的（系统级故障、数据和介质故障、自然灾害、人为破坏、供电问题）；有计划的（日常任务、运维相关、升级相关）。&lt;/li&gt;
  &lt;li&gt;故障原因分类：网络、性能、安全、运维、管理、硬件。&lt;/li&gt;
  &lt;li&gt;故障不可避免：故障是正常的，而且是常见的；故障是不可预测突发的，而且相当难缠。所以，不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day08-洞悉PaaS平台的本质</title><link href="http://localhost:4000/code/2019/12/23/cxze60-day08.html" rel="alternate" type="text/html" title="【60天重学左耳】Day08-洞悉PaaS平台的本质" /><published>2019-12-23T22:00:00+08:00</published><updated>2019-12-23T22:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/23/cxze60-day08</id><content type="html" xml:base="http://localhost:4000/code/2019/12/23/cxze60-day08.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day8：今天学习了《27｜洞悉PaaS平台的本质》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;软件工程能力主要体现在：提高服务的SLA、能力和资源重用或复用、过程的自动化。&lt;/li&gt;
  &lt;li&gt;PaaS平台的本质：服务化（模块重用、服务治理、对外提供能力）、分布式（多租户隔离、高可用、服务编排）、自动化（自动化部署安装运维、自动化伸缩调度）。&lt;/li&gt;
  &lt;li&gt;PaaS平台的总体架构：调度层（自动化和分布式对于高可用高性能的管理）、能力服务层（提供给用户的服务和能力）、流量调度（对高并发的管理）、运营管理（软件资源库、软件接入、认证和开放平台门户）、运维管理（DevOps）。&lt;/li&gt;
  &lt;li&gt;PaaS平台的生产和运维流程：软件构建 =&amp;gt; 软件资产库（Docker Registry） =&amp;gt; DevOps =&amp;gt; 架构控制器 =&amp;gt; 生产环境 =&amp;gt; Docker+Kubernetes集群 =&amp;gt; 软件部署和生产变更。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day05-分布式系统关键技术：流量与数据调度</title><link href="http://localhost:4000/code/2019/12/20/cxze60-day05.html" rel="alternate" type="text/html" title="【60天重学左耳】Day05-分布式系统关键技术：流量与数据调度" /><published>2019-12-20T21:00:00+08:00</published><updated>2019-12-20T21:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/20/cxze60-day05</id><content type="html" xml:base="http://localhost:4000/code/2019/12/20/cxze60-day05.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day5：今天学习了《26｜分布式系统关键技术：流量与数据调度》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务治理与流量调度的区别：服务治理主内，是数据中心的事，流量调度主内也主外，是数据中心之外的事，也就是边缘计算如CDN。&lt;/li&gt;
  &lt;li&gt;流量调度主要完成：服务流控（服务的发现、路由、降级、熔断、保护）、流量控制（负载均衡、流量分配、异地灾备或多活）、流量管理（协议转换、请求校验、数据缓存、数据计算），这些通常由API Gateway搞定。&lt;/li&gt;
  &lt;li&gt;流量调度的关键技术：高性能（使用高性能语言）、扛流量（集群、通讯协议如Paxos、Raft、Gossip）、业务逻辑（可注入不同语言的简单逻辑如AWS的Lambda）、服务化（提供Admin API管理配置变更）。&lt;/li&gt;
  &lt;li&gt;状态数据调度，一般会把有状态的服务数据存储到中间件上，比如Redis、MySQL、ZooKeeper、或是NFS、Ceph等文件系统。&lt;/li&gt;
  &lt;li&gt;数据副本是分布式系统解决数据丢失异常的手段：让数据高可用就得写多份的，写多份就会引起一致性问题，解决一致性又会引发性能问题。&lt;/li&gt;
  &lt;li&gt;解决数据副本间的一致性问题的技术方案：Master-Slave、Master-Master、两阶段和三阶段提交、Paxos。解决事务问题，在应用层上首选两阶段提交、在数据层上首选Paxos。&lt;/li&gt;
  &lt;li&gt;状态数据调度由分布式存储系统来解决会更有效和优雅，分库分表的数据库中间件都会成为过渡技术。在Iaas层解决的方法：廉价的开源产品如NFS、Ceph、TiDB、CockroachDB、ElasticSearch、InfluxDB、MySQL Cluster、Redis Cluster；云计算厂商方案；更为昂贵的商业网络存储方案。&lt;/li&gt;
  &lt;li&gt;因为数据存储的Scheme不同，导致有各式各样的分布式存储系统：文件对象、关系型数据库、NoSQL、时序数据、搜索数据、队列数据。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day04-分布式系统关键技术：服务调度</title><link href="http://localhost:4000/code/2019/12/19/cxze60-day04.html" rel="alternate" type="text/html" title="【60天重学左耳】Day04-分布式系统关键技术：服务调度" /><published>2019-12-19T20:00:00+08:00</published><updated>2019-12-19T20:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/19/cxze60-day04</id><content type="html" xml:base="http://localhost:4000/code/2019/12/19/cxze60-day04.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day4：今天学习了《25｜分布式系统关键技术：服务调度》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务调度的关键技术：关键程度、依赖关系、服务发现、版本管理、生命周期管理。&lt;/li&gt;
  &lt;li&gt;服务关键程度，通过细致管理对业务的理解来定义。&lt;/li&gt;
  &lt;li&gt;微服务是服务依赖最优解的上限，下限是千万不要有依赖环。&lt;/li&gt;
  &lt;li&gt;服务依赖关系可以通过Zipkin服务调用跟踪系统来梳理。&lt;/li&gt;
  &lt;li&gt;服务注册中心用来知道：服务数量、服务版本、服务实例数量及状态、服务总体状态。&lt;/li&gt;
  &lt;li&gt;服务状态包括：Provision、Ready、Run、Update、Rollback、Scale、Destroy、Failed。&lt;/li&gt;
  &lt;li&gt;版本管理，即由一堆服务的版本所形成的整个架构的版本控制，用以解决各个服务的版本兼容问题。使用场景如，回滚一个服务的版本，就要把与之有版本依赖的服务也一起回滚。&lt;/li&gt;
  &lt;li&gt;服务调度的关键技术：服务状态的维持和拟合、弹性伸缩和故障迁移、作业和应用调度、作业工作流编排、服务编排。&lt;/li&gt;
  &lt;li&gt;服务运行中状态的变化包括：不预期变化（如故障导致服务挂掉）、预期变化（如发布新版本）。&lt;/li&gt;
  &lt;li&gt;Scale一般步骤：扩展结点 -&amp;gt; 部署服务 -&amp;gt; 启动服务 -&amp;gt; 检查健康 -&amp;gt; 加入服务发现。&lt;/li&gt;
  &lt;li&gt;拟合：控制系统进行若干次操作，努力逼近最终状态、直到完全达到的过程。&lt;/li&gt;
  &lt;li&gt;故障恢复的模式：宠物模式（一定要救活，主要是对于有状态服务）、奶牛模式（重新生成一个实例）。&lt;/li&gt;
  &lt;li&gt;微服务一般使用API网关或消息队列来做编排（Orchestration）。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day03-分布式系统关键技术：全栈监控</title><link href="http://localhost:4000/code/2019/12/18/cxze60-day03.html" rel="alternate" type="text/html" title="【60天重学左耳】Day03-分布式系统关键技术：全栈监控" /><published>2019-12-18T20:00:00+08:00</published><updated>2019-12-18T20:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/18/cxze60-day03</id><content type="html" xml:base="http://localhost:4000/code/2019/12/18/cxze60-day03.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day3：今天学习了《24｜分布式系统关键技术：全栈监控》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;监控系统需要完成的功能：全栈监控、关联分析、跨系统调用的串联、实时报警和自动处置、性能分析。&lt;/li&gt;
  &lt;li&gt;全栈监控主要包括三层监控：基础层如CPU、中间层如Nginx、应用层如HTTP响应时间。&lt;/li&gt;
  &lt;li&gt;监控标准化：日志数据结构化、监控数据格式标准化、统一监控平台、统一日志分析。&lt;/li&gt;
  &lt;li&gt;差的监控系统特征：监控数据是隔离开来的串不起来、监控的数据项太多抓不住重点。&lt;/li&gt;
  &lt;li&gt;好的监控系统特征：关注整体SLA，从用户API来监控；关键指标聚合，把服务实例和主机关联起来；快速故障定位，对整个分布式系统做一个用户请求跟踪的trace监控，最好无倾入。&lt;/li&gt;
  &lt;li&gt;监控系统使用场景，体检：容量管理、性能管理；急诊：定位问题、性能分析。&lt;/li&gt;
  &lt;li&gt;监控系统功能：服务调用链跟踪（Zipkin）、服务调用时长分布（Zipkin）、服务的TOP N视图（调用量、请求耗时、热点）、数据库操作关联（JavaAgent字节码）、服务资源跟踪（CPU、MEM、I/O、DISK、NETWORK）。&lt;/li&gt;
  &lt;li&gt;分布式系统最重要的事就是把监控系统做好。收集好数据同时，更重要的是把数据关联好。这样才可能很快地定位故障，进而才能进行自动化调度。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry><entry><title type="html">【60天重学左耳】Day02-分布式系统的技术栈</title><link href="http://localhost:4000/code/2019/12/17/cxze60-day02.html" rel="alternate" type="text/html" title="【60天重学左耳】Day02-分布式系统的技术栈" /><published>2019-12-17T23:00:00+08:00</published><updated>2019-12-17T23:00:00+08:00</updated><id>http://localhost:4000/code/2019/12/17/cxze60-day02</id><content type="html" xml:base="http://localhost:4000/code/2019/12/17/cxze60-day02.html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/177414?utm_term=zeusL3AA0&amp;amp;utm_source=wechat&amp;amp;utm_medium=chongxuedaka&quot;&gt;左耳朵耗子带你重学《左耳听风》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打卡Day2：今天学习了《23｜分布式系统的技术栈》，我的收获如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;分布式系统要干的两件事：提高整体吞吐量服务更多并发和流量、提高系统稳定性让可用性更高。&lt;/li&gt;
  &lt;li&gt;提高性能技术包括：缓存、负载均衡、异步调用、数据分区或镜像。&lt;/li&gt;
  &lt;li&gt;提高稳定性技术包括：服务拆分、服务冗余、限流降级、高可用架构、高可用运维。&lt;/li&gt;
  &lt;li&gt;分布式系统的纲，即最最核心的东西：全栈系统监控、服务/资源调度、流量调度、状态/数据调度、开发和运维的自动化。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">左耳朵耗子带你重学《左耳听风》</summary></entry></feed>